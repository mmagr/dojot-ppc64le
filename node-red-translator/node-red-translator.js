
/**
 * Translate a JSON from node-RED to a perseo-fe request (only 
 * body part).
 */

var fs = require('fs');
var filename = process.argv[2];
var util = require('util');
var objects = {};

NodeRed = {
  NodeType : {
    OUTPUT_DEVICE : 'device in',
    INPUT_DEVICE : 'device out',
    SWITCH : 'switch',
    CHANGE : 'change',
    HTTP_REQUEST : 'http request',
    TEMPLATE : 'template'
  },
  LogicalOperators : {
    "eq" : "==",
    "neq" : "!=",
    "lt" : "<",
    "lte" : "<=",
    "gt" : ">",
    "gte" : ">=",
    "btwn" : "between",
    /*
    - not yet - 
    "cont" : "contains",
    "regex" : "regex",
    "true" : "1",
    "false" : "0",
    "null" : "null",
    "nnull" : "!null"
    */
  },
  ValueTypes : {
    FLOAT: 'num',
    STRING: 'str',
    BOOL: 'bool'
  }
}

PerseoTypes = {
  ActionType : {
    UPDATE :'update',
    POST : 'post'
  }
}

/**
 * @typedef {Object} Request
 * @property {String} name Rule name
 * @property {Array} variables Array of strings selecting and naming variables from the request.
 * @property {Object} pattern Pattern to be matched to fire the rule. This property contains the
 * device type and an array of filters (in the form 'Variable? == value', in plain Strings)
 * @property {Object} action The action to be taken when an event matches this rule. Possible
 * types are:
 *  - NodeRed.NodeType.CHANGE : updates a variable in orion
 *  - NodeRed.NodeType.HTTP_REQUEST : sends a HTTP message to an arbitrary endpoint
 * @property {String} output_device: The device to be updated, if needed.
 */
var perseo_template = {
  "name": "",
  "variables": [],
  "pattern": {
    "type": "",
    "other_filters": []
  },
  "action": {
    "type": "",
    "template": "",
    "parameters": { }
  },
  "output_device" : ""
};

/**
 * Wrapper that performs a deep copy of a request
 * @param {Request} request Request to be cloned
 */
function clone_request(request) {
  return JSON.parse(JSON.stringify(request));
}

/**
 * Read JSON file generated by node-RED
 * @param {String} filename The file to be read
 * @returns {Object} The JSON object
 */
function read_json(filename) {
  return JSON.parse(fs.readFileSync(filename, 'utf8'));
}

/**
 * Remove a particular keyword from a string
 * @param {String} property The property being changed
 * @param {String} keyword The keyword to be removed
 */
function trim_property(property, keyword) {
  var payload_len = keyword.length;
  return property.slice(property.indexOf(keyword) + payload_len);
}

function generate_cast_from_value_type(property, node_red_type) {
  switch (node_red_type) {
    case NodeRed.ValueTypes.FLOAT:
      return 'cast(cast(' + property + ', String), float)';
    break;
    case NodeRed.ValueTypes.STRING:
      return 'cast(' + property + ', String)';
      break;
    case NodeRed.ValueTypes.BOOL:
      return 'cast(cast(' + property + ', String), integer)';
      break;
    default:
      return 'cast(' + property + ', String)';
  }
}

function convert_node_red_value_type(type) {
  switch (type) {
    case NodeRed.ValueTypes.FLOAT:
      return 'float';
    break;
    case NodeRed.ValueTypes.STRING:
      return 'string';
    default:
      return 'string';
  }
}

/**
 * Converts a moustache-encoded string with variables to something like a bash string with variables.
 * @param {String} template The template being translated
 * @param {Array} detected_variables Array of detected variables
 */
function extract_variables(template, detected_variables) {
  var begin_tag_index = template.search('{{');
  var end_tag_index = template.search('}}');
  var translated_template = undefined;
  if ((begin_tag_index >= 0) && (end_tag_index >= 0) && (begin_tag_index < end_tag_index)) {
    var begin = template.slice(0, begin_tag_index);
    begin_tag_index += 2;
    var tag = template.slice(begin_tag_index, end_tag_index);
    end_tag_index += 2;
    var remaining = template.slice(end_tag_index);
    var converted_tag = trim_property(tag, "payload.");
    detected_variables.push('ev.' + converted_tag + '? as ' + converted_tag);
    translated_template = begin + '${' + converted_tag + '}' + remaining;
    translated_template = extract_variables(translated_template, detected_variables);
    
  } else {
    translated_template = template;
  }
  return translated_template;
}

function add_filter(node, rule_op, rule_val, rule_type, request) {
  // As this is a 'dynamic' property for perseo, it must end with a question mark.
  var node_property = trim_property(node.property, 'payload.') + '?';
  var node_property_with_cast = generate_cast_from_value_type(node_property, rule_type);
  request.pattern.other_filters.push(node_property_with_cast + ' ' + NodeRed.LogicalOperators[rule_op] + ' ' + rule_val);
}

/**
 * Extract content from node-RED nodes and translate them
 * to related structures in perseo-fe request.
 * @param {Object} node node-RED node to be analyzed
 * @param {Request} request Current perseo-fe request. Keep in mind that
 * a particular node in node-RED can generate multiple requests for
 * perseo-fe
 * @param {String} device_type The current device being analyzed (source
 * device).
 */
function extract_data_from_node(node, request, device_type, device_name) {
  var next_node = undefined;
  var perseo_request_results = [];
  var temp_results = [];

  switch (node.type) {
    case NodeRed.NodeType.OUTPUT_DEVICE:
      var request_clone = clone_request(request);
      request_clone.output_device = node.name;
      perseo_request_results.push(request_clone);
      break;
    case NodeRed.NodeType.INPUT_DEVICE:
      // Check all further nodes - this is the source.
      for (var wireset = 0; wireset < node.wires.length; wireset++) {
        for (var wire = 0; wire < node.wires[wireset].length; wire++) {
          // Create a new request so that it can be modified by other boxes.
          var request_clone = clone_request(request);
          next_node = objects[node.wires[wireset][wire]];
          var result = extract_data_from_node(next_node, request_clone, node.device, node.name);
          perseo_request_results = temp_results.concat(result);
          temp_results = perseo_request_results;
        }
      }
      break;
    case NodeRed.NodeType.SWITCH: 
      var rule_op = undefined;
      var rule_val = undefined;
      var rule_type = undefined;
      // Each wireset inherently iterates over rules
      for (var wireset = 0; wireset < node.wires.length; wireset++) {
          rule_op = node.rules[wireset].t;
          if (rule_op in NodeRed.LogicalOperators) {
            // If this operator is supported.
            var request_clone = clone_request(request);
            rule_val = node.rules[wireset].v;
            rule_type = node.rules[wireset].vt;
            if (rule_op == 'btwn') {
              rule_op = 'gte';
              add_filter(node, rule_op, rule_val, rule_type, request_clone);
              rule_op = 'lte';
              rule_val = node.rules[wireset].v2;
              rule_type = node.rules[wireset].v2t;
              add_filter(node, rule_op, rule_val, rule_type, request_clone);
            } else {
              add_filter(node, rule_op, rule_val, rule_type, request_clone);
            }
            
            request_clone.pattern.type = device_type;
            for (var wire = 0; wire < node.wires[wireset].length; wire++) { 
              next_node = objects[node.wires[wireset][wire]];
              var result = extract_data_from_node(next_node, request_clone, device_type, device_name);
              perseo_request_results = temp_results.concat(result);
              temp_results = perseo_request_results;
            }
          
        }
      }
      break;
    case NodeRed.NodeType.CHANGE:
      // Need to create a new request for each rule
      for (var rule = 0; rule < node.rules.length; rule++) {
        // Other possible rules are: delete and move.
        if (node.rules[rule].t == 'set' || node.rules[rule].t == 'change') {
          var request_clone = clone_request(request);
          request_clone.action.type = PerseoTypes.ActionType.UPDATE;
          request_clone.action.parameters = {
              "attributes": [
                  {
                      "name": trim_property(node.rules[rule].p, 'payload.'),
                      "type": convert_node_red_value_type(node.rules[rule].tot),
                      "value": node.rules[rule].to
                  }
              ]
          };

          // Keep checking further boxes - there might be further switches and other actions
          for (var wireset = 0; wireset < node.wires.length; wireset++) {
            for (var wire = 0; wire < node.wires[wireset].length; wire++) {
              next_node = objects[node.wires[wireset][wire]];
              var result = extract_data_from_node(next_node, request_clone, device_type, device_name);
              perseo_request_results = temp_results.concat(result);
              temp_results = perseo_request_results;
            }
          }
        }
      }
      
      break;
    case NodeRed.NodeType.HTTP_REQUEST:
      switch (node.method) {
        case "POST":
          request.action.type = PerseoTypes.ActionType.POST;
          request.action.parameters = { 
            "url" : node.url,
            "method" : "POST",
            "headers" : { 
              "Content-type" : "text/plain"
            }
          };
        break;
      }
      perseo_request_results.push(request);
      temp_results = perseo_request_results;
      break;
    case NodeRed.NodeType.TEMPLATE:
      var request_clone = clone_request(request);
      var detected_variables = [];
      request_clone.action.template = extract_variables(node.template, detected_variables);
      var full_var_list = request_clone.variables.concat(detected_variables);
      request_clone.variables = full_var_list;
      // Do the string substitution
      // Keep checking further boxes - there might be further switches and other actions
      for (var wireset = 0; wireset < node.wires.length; wireset++) {
        for (var wire = 0; wire < node.wires[wireset].length; wire++) {
          next_node = objects[node.wires[wireset][wire]];
          var result = extract_data_from_node(next_node, request_clone, device_type, device_name);
          perseo_request_results = temp_results.concat(result);
          temp_results = perseo_request_results;
        }
      }
      break;
  }
  return perseo_request_results;
}

/**
 * Transform the internal representation of perseo-fe requests to a format
 * that it actually can process.
 * @param {Request} requests An array of requests to be transformed.
 * @returns {PerseoRequest} An array of objects containing the properly transformed
 * requests.
 */
function transform_to_perseo_request(requests) {
  perseo_requests = [];

  for (var i = 0; i < requests.length; i++) {
    var perseo_request = {};
    var rule_name = 'rule_' + i;
    perseo_request['name'] = rule_name;
    perseo_request['text'] = 'select *';
    perseo_request['text'] += ', \"' + rule_name + '\" as ruleName';
    perseo_request['text'] += ', ev.type as Type';
    perseo_request['text'] += ', ev.id as ID';
    for (var othervar = 0; othervar < requests[i].variables.length; othervar++) {
      perseo_request['text'] += ', ' + requests[i].variables[othervar];
    }
    
    perseo_request['text'] += ' from pattern [';
    perseo_request['text'] += 'ev = iotEvent(';
    perseo_request['text'] += 'type == \"' + requests[i].pattern.type + '\" ';
    for (var filter = 0; filter < requests[i].pattern.other_filters.length; filter++) {
      perseo_request['text'] += 'and ' + requests[i].pattern.other_filters[filter] + ' ';
    }
    perseo_request['text'] += ')]';
    perseo_request['action'] = requests[i].action;
    if (requests[i].action.type == PerseoTypes.ActionType.UPDATE) {
      perseo_request.action.parameters['id'] = requests[i].output_device;
    }
    perseo_requests.push(perseo_request);
  }
  return perseo_requests;
}

/**
 * Translate a mashup from node-RED to a series of requests to perseo-fe.
 * @param {String} filename The file containing the node-RED mashup description
 * @returns An array of objects ready to be added to the body of a HTTP POST message
 * to perseo-fe.
 */
function translate_mashup(filename) {
  var results = [];
  var temp_results = [];

  var boxes = read_json(filename);
  for (var i = 0; i < boxes.length; i++) {
    objects[boxes[i].id] = boxes[i];
  }

  for (var id in objects) {
    if (objects[id].type == 'device out') {
      var perseo_request = clone_request(perseo_template);
      var ret = extract_data_from_node(objects[id], perseo_request, objects[id].device);
      ret = transform_to_perseo_request(ret)
      temp_results = results.concat(ret);
      results = temp_results;
    }
  }
  return results;
}

exports.translate_mashup = translate_mashup;